---
description: Complete SQLAlchemy 2.0+ async patterns, best practices, and integration examples for Python applications
globs:
  - "**/models/**/*.py"
  - "**/database/**/*.py"
  - "**/db/**/*.py"
  - "**/*model*.py"
  - "**/*schema*.py"
alwaysApply: false
---

# Python SQLAlchemy 2.0+ Standards

Comprehensive guide for SQLAlchemy 2.0+ with async patterns, covering model definitions, query patterns, session management, Alembic migrations, and FastAPI integration.

**For PostgreSQL database concepts, see:** `.claude/context/database/postgresql-standards.mdc`

## Table of Contents

1. [Async Base Configuration](#async-base-configuration)
2. [Model Definitions](#model-definitions)
3. [Relationships](#relationships)
4. [Session Management](#session-management)
5. [Query Patterns](#query-patterns)
6. [Eager Loading](#eager-loading)
7. [Alembic Migrations](#alembic-migrations)
8. [FastAPI Integration](#fastapi-integration)
9. [Anti-Patterns to Avoid](#anti-patterns-to-avoid)

---

## Async Base Configuration

### Base Class with AsyncAttrs

**ALWAYS use AsyncAttrs for async lazy loading support.**

```python
from sqlalchemy.ext.asyncio import AsyncAttrs
from sqlalchemy.orm import DeclarativeBase

class Base(AsyncAttrs, DeclarativeBase):
    """
    Base class for all SQLAlchemy models.
    AsyncAttrs enables async attribute loading for relationships.
    """
    pass
```

### Database Engine Configuration

**Use create_async_engine with proper connection pooling.**

```python
import os
from sqlalchemy.ext.asyncio import (
    create_async_engine,
    async_sessionmaker,
    AsyncSession,
)

# GOOD: Production-ready engine configuration
DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise ValueError("DATABASE_URL environment variable not set")

engine = create_async_engine(
    DATABASE_URL,
    echo=False,  # Set to True only in development for SQL logging
    pool_size=20,  # Adjust based on concurrent requests
    max_overflow=10,  # Additional connections for traffic spikes
    pool_pre_ping=True,  # Test connections before use (handles stale connections)
    pool_recycle=3600,  # Recycle connections after 1 hour
    pool_timeout=30,  # Timeout waiting for connection from pool
)

# Session factory
async_session_maker = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,  # Prevent lazy loading after commit
)
```

**Connection Pool Guidelines:**
- Small app (< 10 concurrent): `pool_size=5-10`
- Medium app (10-100 concurrent): `pool_size=20-30`
- Large app (100+ concurrent): `pool_size=50+`, consider read replicas

---

## Model Definitions

### Basic Model with Type Hints

**ALL columns MUST use Mapped[] type annotations.**

```python
from datetime import datetime
from typing import Optional
from sqlalchemy import String, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column

class User(Base):
    __tablename__ = "users"

    # Primary key
    id: Mapped[int] = mapped_column(primary_key=True)

    # Required fields
    email: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)
    username: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)

    # Optional fields (use Optional[] type hint)
    full_name: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    phone: Mapped[Optional[str]] = mapped_column(String(20), nullable=True)

    # Boolean with default
    is_active: Mapped[bool] = mapped_column(default=True, nullable=False)
    is_superuser: Mapped[bool] = mapped_column(default=False, nullable=False)

    # Timestamps (timezone-aware)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False
    )

    def __repr__(self) -> str:
        return f"<User(id={self.id}, email={self.email})>"
```

### Model with Foreign Keys and Indexes

**Foreign keys MUST have explicit indexes for JOIN performance.**

**For index strategies (B-tree, GIN, GiST, BRIN), see:** `.claude/context/database/postgresql-standards.mdc`

```python
from sqlalchemy import ForeignKey, String, Numeric, DateTime, Index
from sqlalchemy.orm import Mapped, mapped_column
from decimal import Decimal

class Order(Base):
    __tablename__ = "orders"

    # Primary key
    id: Mapped[int] = mapped_column(primary_key=True)

    # Foreign key with index=True
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"),
        index=True,  # CRITICAL: Add index for JOIN performance
        nullable=False
    )

    # Order data
    status: Mapped[str] = mapped_column(
        String(20),
        default="pending",
        nullable=False,
        index=True  # Frequently queried
    )
    total: Mapped[Decimal] = mapped_column(Numeric(10, 2), nullable=False)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False
    )

    # Composite index for common query pattern
    __table_args__ = (
        Index("ix_orders_user_status_date", "user_id", "status", "created_at"),
    )

    def __repr__(self) -> str:
        return f"<Order(id={self.id}, user_id={self.user_id}, total={self.total})>"
```

### Model with Constraints

**For constraint concepts, see:** `.claude/context/database/postgresql-standards.mdc#constraints`

```python
from sqlalchemy import (
    String, Integer, Numeric, Boolean, DateTime, CheckConstraint,
    UniqueConstraint, Index, Text
)
from sqlalchemy.orm import Mapped, mapped_column

class Product(Base):
    __tablename__ = "products"

    id: Mapped[int] = mapped_column(primary_key=True)
    sku: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)
    name: Mapped[str] = mapped_column(String(200), nullable=False, index=True)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    price: Mapped[Decimal] = mapped_column(Numeric(10, 2), nullable=False)
    stock_count: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    discount_percent: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)

    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False
    )

    # Constraints
    __table_args__ = (
        CheckConstraint("price > 0", name="chk_price_positive"),
        CheckConstraint("stock_count >= 0", name="chk_stock_non_negative"),
        CheckConstraint(
            "discount_percent BETWEEN 0 AND 100",
            name="chk_discount_range"
        ),
        Index("ix_products_name_active", "name", "is_active"),
    )
```

---

## Relationships

### One-to-Many Relationships

**ALWAYS use back_populates for bidirectional relationships.**

```python
from typing import List
from sqlalchemy.orm import Mapped, mapped_column, relationship

class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True)

    # One-to-many: User has many Orders
    orders: Mapped[List["Order"]] = relationship(
        "Order",
        back_populates="user",
        cascade="all, delete-orphan",  # Delete orders when user deleted
        lazy="selectin"  # Default eager loading strategy
    )

class Order(Base):
    __tablename__ = "orders"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE"),
        index=True,  # CRITICAL: Index foreign key
        nullable=False
    )
    total: Mapped[Decimal] = mapped_column(Numeric(10, 2))

    # Many-to-one: Order belongs to User
    user: Mapped["User"] = relationship(
        "User",
        back_populates="orders"
    )
```

### Many-to-Many Relationships

**Use association table for many-to-many.**

```python
from sqlalchemy import Table, Column, Integer, ForeignKey

# Association table
user_roles_table = Table(
    "user_roles",
    Base.metadata,
    Column("user_id", Integer, ForeignKey("users.id"), primary_key=True),
    Column("role_id", Integer, ForeignKey("roles.id"), primary_key=True),
)

class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True)

    # Many-to-many: User has many Roles
    roles: Mapped[List["Role"]] = relationship(
        "Role",
        secondary=user_roles_table,
        back_populates="users"
    )

class Role(Base):
    __tablename__ = "roles"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(50), unique=True)

    # Many-to-many: Role has many Users
    users: Mapped[List["User"]] = relationship(
        "User",
        secondary=user_roles_table,
        back_populates="roles"
    )
```

### Cascade Configuration

```python
class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)

    # CASCADE: Delete orders when user is deleted
    orders: Mapped[List["Order"]] = relationship(
        "Order",
        back_populates="user",
        cascade="all, delete-orphan",  # Deletes orders with user
        passive_deletes=True  # Let database handle ON DELETE CASCADE
    )
```

**Cascade Options:**
- `"all"` - All operations cascade (save-update, merge, delete, etc.)
- `"delete"` - Delete related objects
- `"delete-orphan"` - Delete objects removed from relationship
- `"save-update"` - Save/update related objects (default)

---

## Session Management

### Session Factory with FastAPI

**Session per request pattern using FastAPI Depends().**

```python
from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
from fastapi import Depends
from typing import AsyncGenerator

# Engine and session factory
engine = create_async_engine(
    os.getenv("DATABASE_URL"),
    pool_pre_ping=True,
    pool_recycle=3600,
)

async_session_maker = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

# Dependency for FastAPI routes
async def get_session() -> AsyncGenerator[AsyncSession, None]:
    """
    Create a new database session for each request.
    Session is automatically closed after request completes.
    """
    async with async_session_maker() as session:
        try:
            yield session
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

# Usage in FastAPI route
from fastapi import APIRouter

router = APIRouter()

@router.get("/users/{user_id}")
async def get_user(
    user_id: int,
    session: AsyncSession = Depends(get_session)
):
    """Get user by ID."""
    stmt = select(User).where(User.id == user_id)
    result = await session.execute(stmt)
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    return user
```

### Transaction Management

**For transaction concepts, see:** `.claude/context/database/postgresql-standards.mdc#transaction-management`

```python
async def create_user_with_profile(
    session: AsyncSession,
    user_data: dict,
    profile_data: dict
) -> User:
    """
    Create user and profile in a transaction.
    If either fails, both are rolled back.
    """
    try:
        # Create user
        user = User(**user_data)
        session.add(user)
        await session.flush()  # Flush to get user.id

        # Create profile using user.id
        profile = Profile(user_id=user.id, **profile_data)
        session.add(profile)

        # Commit transaction
        await session.commit()

        # Refresh to load relationships
        await session.refresh(user)

        return user

    except Exception as e:
        await session.rollback()
        raise
```

---

## Query Patterns

### Basic Queries with select()

**ALWAYS use select() for queries (not legacy Query API).**

```python
from sqlalchemy import select, and_, or_, func
from sqlalchemy.ext.asyncio import AsyncSession

# Get single object by ID
async def get_user_by_id(session: AsyncSession, user_id: int) -> Optional[User]:
    stmt = select(User).where(User.id == user_id)
    result = await session.execute(stmt)
    return result.scalar_one_or_none()

# Get all objects
async def get_all_users(session: AsyncSession) -> List[User]:
    stmt = select(User)
    result = await session.scalars(stmt)
    return result.all()

# Filter with WHERE clause
async def get_active_users(session: AsyncSession) -> List[User]:
    stmt = select(User).where(User.is_active == True)
    result = await session.scalars(stmt)
    return result.all()

# Multiple conditions with AND
async def get_active_superusers(session: AsyncSession) -> List[User]:
    stmt = select(User).where(
        and_(
            User.is_active == True,
            User.is_superuser == True
        )
    )
    result = await session.scalars(stmt)
    return result.all()

# LIKE pattern matching
async def search_users_by_name(session: AsyncSession, query: str) -> List[User]:
    stmt = select(User).where(User.name.like(f"%{query}%"))
    result = await session.scalars(stmt)
    return result.all()

# IN clause
async def get_users_by_ids(
    session: AsyncSession,
    user_ids: List[int]
) -> List[User]:
    stmt = select(User).where(User.id.in_(user_ids))
    result = await session.scalars(stmt)
    return result.all()

# ORDER BY
async def get_users_sorted(session: AsyncSession) -> List[User]:
    stmt = select(User).order_by(User.created_at.desc())
    result = await session.scalars(stmt)
    return result.all()

# LIMIT and OFFSET (pagination)
async def get_users_page(
    session: AsyncSession,
    page: int = 1,
    per_page: int = 50
) -> List[User]:
    stmt = (
        select(User)
        .order_by(User.created_at.desc())
        .limit(per_page)
        .offset((page - 1) * per_page)
    )
    result = await session.scalars(stmt)
    return result.all()
```

### Aggregate Queries

**Use func for aggregate operations.**

```python
from sqlalchemy import func, select

# COUNT
async def count_users(session: AsyncSession) -> int:
    stmt = select(func.count()).select_from(User)
    result = await session.execute(stmt)
    return result.scalar_one()

# SUM
async def get_total_revenue(session: AsyncSession) -> Decimal:
    stmt = select(func.sum(Order.total))
    result = await session.execute(stmt)
    return result.scalar_one() or Decimal(0)

# GROUP BY
async def get_orders_by_status(session: AsyncSession) -> List[dict]:
    stmt = (
        select(
            Order.status,
            func.count(Order.id).label("count"),
            func.sum(Order.total).label("total"),
        )
        .group_by(Order.status)
    )
    result = await session.execute(stmt)

    return [
        {"status": row.status, "count": row.count, "total": row.total}
        for row in result
    ]
```

### Update and Delete Operations

```python
from sqlalchemy import update, delete

# Update single record
async def update_user_email(
    session: AsyncSession,
    user_id: int,
    new_email: str
) -> None:
    stmt = (
        update(User)
        .where(User.id == user_id)
        .values(email=new_email, updated_at=func.now())
    )
    await session.execute(stmt)
    await session.commit()

# Bulk update
async def deactivate_inactive_users(session: AsyncSession) -> int:
    """Deactivate users not logged in for 365 days."""
    stmt = (
        update(User)
        .where(User.last_login < func.now() - func.interval("365 days"))
        .values(is_active=False, updated_at=func.now())
    )
    result = await session.execute(stmt)
    await session.commit()
    return result.rowcount  # Number of rows updated

# Delete single record
async def delete_user(session: AsyncSession, user_id: int) -> None:
    stmt = delete(User).where(User.id == user_id)
    await session.execute(stmt)
    await session.commit()
```

---

## Eager Loading

### Preventing N+1 Queries

**ALWAYS use eager loading when accessing relationships in loops.**

```python
from sqlalchemy.orm import selectinload, joinedload, contains_eager

# BAD: N+1 query problem
async def get_users_with_orders_BAD(session: AsyncSession) -> List[User]:
    stmt = select(User)
    result = await session.scalars(stmt)
    users = result.all()

    # This causes N+1 queries!
    for user in users:
        for order in user.orders:  # Each access triggers a query!
            print(f"Order {order.id}")

    # Total queries: 1 for users + N for orders = N+1

# GOOD: Use selectinload for one-to-many
async def get_users_with_orders(session: AsyncSession) -> List[User]:
    stmt = select(User).options(selectinload(User.orders))
    result = await session.scalars(stmt)
    users = result.all()

    for user in users:
        for order in user.orders:  # Already loaded!
            print(f"Order {order.id}")

    # Total queries: 2 (1 for users, 1 for all orders)

# GOOD: Use joinedload for many-to-one
async def get_orders_with_users(session: AsyncSession) -> List[Order]:
    stmt = select(Order).options(joinedload(Order.user))
    result = await session.scalars(stmt)
    orders = result.all()

    for order in orders:
        print(f"User: {order.user.email}")  # Already loaded!

    # Total queries: 1 (single JOIN query)
```

### Nested Eager Loading

**Chain options for nested relationships.**

```python
# Load users with orders and order items
async def get_users_with_full_orders(session: AsyncSession) -> List[User]:
    stmt = select(User).options(
        selectinload(User.orders).selectinload(Order.items)
    )
    result = await session.scalars(stmt)
    return result.all()

# Load orders with user and items with product
async def get_complete_orders(session: AsyncSession) -> List[Order]:
    stmt = select(Order).options(
        joinedload(Order.user),
        selectinload(Order.items).joinedload(OrderItem.product),
    )
    result = await session.scalars(stmt)
    return result.all()
```

### selectinload vs joinedload

**Choose the right eager loading strategy.**

```python
# selectinload: Best for one-to-many relationships
# Issues separate SELECT query
async def get_users_with_orders_selectinload(session: AsyncSession):
    stmt = select(User).options(selectinload(User.orders))
    # Query 1: SELECT * FROM users
    # Query 2: SELECT * FROM orders WHERE user_id IN (1, 2, 3, ...)
    result = await session.scalars(stmt)
    return result.all()

# joinedload: Best for many-to-one or one-to-one relationships
# Uses LEFT OUTER JOIN
async def get_orders_with_user_joinedload(session: AsyncSession):
    stmt = select(Order).options(joinedload(Order.user))
    # Single query: SELECT * FROM orders LEFT JOIN users ON ...
    result = await session.scalars(stmt)
    return result.all()

# contains_eager: When you've already joined in query
async def get_orders_with_user_contains_eager(session: AsyncSession):
    stmt = (
        select(Order)
        .join(Order.user)
        .where(User.is_active == True)
        .options(contains_eager(Order.user))
    )
    result = await session.scalars(stmt)
    return result.all()
```

---

## Alembic Migrations

### Initialization

**Initialize Alembic for async SQLAlchemy.**

```bash
# Initialize Alembic
alembic init alembic

# Directory structure created:
# alembic/
# ├── env.py
# ├── script.py.mako
# └── versions/
# alembic.ini
```

### Configure env.py for Async

**Update env.py to support async engine.**

```python
# alembic/env.py
from logging.config import fileConfig
from sqlalchemy import pool
from sqlalchemy.ext.asyncio import create_async_engine
from alembic import context
import asyncio
import os

# Import your models' Base
from app.models import Base

# Alembic Config object
config = context.config

# Interpret the config file for Python logging
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Get database URL from environment
db_url = os.getenv("DATABASE_URL")
if db_url:
    config.set_main_option("sqlalchemy.url", db_url)

# Set target metadata for autogenerate
target_metadata = Base.metadata

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()

def do_run_migrations(connection):
    """Run migrations with connection."""
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    with context.begin_transaction():
        context.run_migrations()

async def run_migrations_online() -> None:
    """Run migrations in 'online' mode with async engine."""
    connectable = create_async_engine(
        config.get_main_option("sqlalchemy.url"),
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()

if context.is_offline_mode():
    run_migrations_offline()
else:
    asyncio.run(run_migrations_online())
```

### Creating Migrations

**Use autogenerate but always review!**

```bash
# Create migration with autogenerate
alembic revision --autogenerate -m "add user email column"

# Create manual migration
alembic revision -m "add custom index"

# Review generated migration file before committing!
```

### Migration File Structure

```python
"""add user email column

Revision ID: ae1027a6acf
Revises: 1975ea83b712
Create Date: 2025-11-21 10:30:45.123456

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = 'ae1027a6acf'
down_revision = '1975ea83b712'
branch_labels = None
depends_on = None

def upgrade() -> None:
    """Add email column to users table."""
    # Add column with temporary NULL allowed
    op.add_column('users', sa.Column('email', sa.String(255), nullable=True))

    # Create index
    op.create_index('ix_users_email', 'users', ['email'])

    # Make column NOT NULL (after ensuring all rows have values)
    # op.alter_column('users', 'email', nullable=False)

def downgrade() -> None:
    """Remove email column from users table."""
    op.drop_index('ix_users_email', 'users')
    op.drop_column('users', 'email')
```

### Applying Migrations

```bash
# Show current revision
alembic current

# Upgrade to latest
alembic upgrade head

# Downgrade one revision
alembic downgrade -1

# Show SQL without executing
alembic upgrade head --sql
```

---

## FastAPI Integration

### Complete FastAPI + SQLAlchemy Setup

```python
# app/database.py
import os
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from typing import AsyncGenerator

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_async_engine(
    DATABASE_URL,
    echo=False,
    pool_size=20,
    max_overflow=10,
    pool_pre_ping=True,
    pool_recycle=3600,
)

async_session_maker = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

async def get_session() -> AsyncGenerator[AsyncSession, None]:
    async with async_session_maker() as session:
        try:
            yield session
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

# app/main.py
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

app = FastAPI()

@app.get("/users/{user_id}")
async def get_user(
    user_id: int,
    session: AsyncSession = Depends(get_session)
):
    stmt = select(User).where(User.id == user_id)
    result = await session.execute(stmt)
    user = result.scalar_one_or_none()

    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    return user

@app.post("/users")
async def create_user(
    user_data: UserCreate,
    session: AsyncSession = Depends(get_session)
):
    user = User(**user_data.dict())
    session.add(user)
    await session.commit()
    await session.refresh(user)
    return user
```

---

## Anti-Patterns to Avoid

### 1. Using Synchronous Session with Async FastAPI

```python
# BAD: Synchronous Session blocks event loop
from sqlalchemy.orm import Session
from sqlalchemy import create_engine

engine = create_engine("postgresql://...")
SessionLocal = sessionmaker(bind=engine)

@app.get("/users")
def get_users():  # Blocking!
    session = SessionLocal()
    users = session.query(User).all()  # Blocks event loop!
    session.close()
    return users

# GOOD: AsyncSession with async/await
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine

engine = create_async_engine("postgresql+asyncpg://...")

@app.get("/users")
async def get_users(session: AsyncSession = Depends(get_session)):
    stmt = select(User)
    result = await session.scalars(stmt)
    return result.all()
```

### 2. Missing Indexes on Foreign Keys

```python
# BAD: Foreign key without index
class Order(Base):
    __tablename__ = "orders"
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"))  # No index!

# GOOD: Foreign key with index
class Order(Base):
    __tablename__ = "orders"
    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), index=True)
```

### 3. N+1 Query Problem

```python
# BAD: N+1 queries
users = await session.scalars(select(User))
for user in users.all():
    for order in user.orders:  # Each access triggers query!
        print(order.id)

# GOOD: Eager loading
users = await session.scalars(select(User).options(selectinload(User.orders)))
for user in users.all():
    for order in user.orders:  # Already loaded!
        print(order.id)
```

### 4. Missing Type Hints

```python
# BAD: No type hints
class User(Base):
    __tablename__ = "users"
    id = mapped_column(Integer, primary_key=True)  # No type hint!
    email = mapped_column(String(255))  # No type hint!

# GOOD: Proper type hints
class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255))
```

### 5. Relationships Without back_populates

```python
# BAD: Missing back_populates
class User(Base):
    orders: Mapped[List["Order"]] = relationship()  # Missing back_populates!

# GOOD: With back_populates
class User(Base):
    orders: Mapped[List["Order"]] = relationship(back_populates="user")

class Order(Base):
    user: Mapped["User"] = relationship(back_populates="orders")
```

---

## Supporting Components

This context file supports:
- **Agent**: `.claude/agents/database/python-database-administrator.md`
- **Commands**: `.claude/commands/database/validate-*.md`
- **PostgreSQL Standards**: `.claude/context/database/postgresql-standards.mdc`

## References

- SQLAlchemy 2.0 Documentation: https://docs.sqlalchemy.org/en/20/
- Alembic Documentation: https://alembic.sqlalchemy.org/
- FastAPI with Databases: https://fastapi.tiangolo.com/tutorial/sql-databases/
